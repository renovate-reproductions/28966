// Copyright (c) 2021-2022, The Tor Project, Inc.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resources

import (
	"encoding/json"

	"gitlab.torproject.org/tpo/anti-censorship/rdsys/pkg/core"
)

const (
	ResourceTypeVanilla      = "vanilla"
	ResourceTypeObfs2        = "obfs2"
	ResourceTypeObfs3        = "obfs3"
	ResourceTypeObfs4        = "obfs4"
	ResourceTypeScrambleSuit = "scramblesuit"
	ResourceTypeMeek         = "meek"
	ResourceTypeSnowflake    = "snowflake"
	ResourceTypeWebSocket    = "websocket"
	ResourceTypeFTE          = "fte"
	ResourceTypeWebtunnel    = "webtunnel"
	ResourceTypeTBLink       = "tblink"
)

type ResourceInfo struct {
	// New creates a new resource of the type
	New func() core.Resource

	// IsAddressDummy indicates if the address on the resource is a dummy placeholder.
	// Some transports like webtunnel will have a address placeholder because is not used to connect to the transport.
	IsAddressDummy bool

	// NeedsPersistantStore indicates if the resource is generated and needs to be stored between rdsys runs.
	// Bridges comming from the bridge descriptors don't need storage, but resources generated by updaters do.
	NeedsPersistantStore bool
}

var ResourceMap = map[string]ResourceInfo{
	ResourceTypeVanilla:      {New: func() core.Resource { return NewBridge() }, IsAddressDummy: false},
	ResourceTypeObfs2:        {New: func() core.Resource { return NewTransport() }, IsAddressDummy: false},
	ResourceTypeObfs3:        {New: func() core.Resource { return NewTransport() }, IsAddressDummy: false},
	ResourceTypeObfs4:        {New: func() core.Resource { return NewTransport() }, IsAddressDummy: false},
	ResourceTypeScrambleSuit: {New: func() core.Resource { return NewTransport() }, IsAddressDummy: false},
	ResourceTypeMeek:         {New: func() core.Resource { return NewTransport() }, IsAddressDummy: true},
	ResourceTypeSnowflake:    {New: func() core.Resource { return NewTransport() }, IsAddressDummy: true},
	ResourceTypeWebSocket:    {New: func() core.Resource { return NewTransport() }, IsAddressDummy: false},
	ResourceTypeFTE:          {New: func() core.Resource { return NewTransport() }, IsAddressDummy: false},
	ResourceTypeWebtunnel:    {New: func() core.Resource { return NewTransport() }, IsAddressDummy: true},
	ResourceTypeTBLink:       {New: func() core.Resource { return NewTBLink() }, NeedsPersistantStore: true},
}

type TmpResourceDiff struct {
	New     map[string][]json.RawMessage
	Changed map[string][]json.RawMessage
	Gone    map[string][]json.RawMessage
}

// UnmarshalTmpResourceDiff unmarshals the raw JSON messages in the given
// temporary hashring into the respective data structures.
func UnmarshalTmpResourceDiff(tmp *TmpResourceDiff) (*core.ResourceDiff, error) {

	ret := core.NewResourceDiff()

	process := func(data map[string][]json.RawMessage) error {
		for k, vs := range data {
			for _, v := range vs {
				rStruct := ResourceMap[k].New()
				if err := json.Unmarshal(v, rStruct); err != nil {
					return err
				}
				ret.New[k] = append(ret.New[k], rStruct.(core.Resource))
			}
		}
		return nil
	}

	if err := process(tmp.New); err != nil {
		return nil, err
	}
	if err := process(tmp.Changed); err != nil {
		return nil, err
	}
	if err := process(tmp.Gone); err != nil {
		return nil, err
	}

	return ret, nil
}
